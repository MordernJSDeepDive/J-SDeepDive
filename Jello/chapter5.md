# 5. 표현식과 문

## 5.1 값

값은 식이 평가(Evaluate)되어 생성된 결과를 의미한다.

여기서 평가란, 식을 해석해서 값을 생성하거나 참조하는 것을 의미한다.

변수는 **하나의 값**을 저장하기 위한 메모리 공간 자체 또는 해당 메모리 공간을 식별하기 위한 이름이다. 이 변수에 할당되는 것이 값이다.  아래 예제의 sum에는 `10 + 20`이 아니라 평가 결과인 숫자 30이 저장된다. 즉, `10 + 20`은 할당 이전에 평가되어 값을 생성한다.

```jsx
var sum = 10 + 20; 
```

## 5.2 리터럴

사람이 이해할 수 있는 문자 또는 약속된 기호를 사용해 **값을 생성하는 표기법(notation)**을 나타낸다.

- 리터럴로 생성할 수 있는 값

| 리터럴 | 예시 |
| --- | --- |
| 정수 | 10 |
| 부동소수점 | 1.5 |
| 2진수 | 10001 |
| 8진수 | 101 |
| 16진수 | 0x4A |
| 문자열 | ‘Hello’, “World” |
| 불리언 | true, false |
| null | null |
| undefined | undefined |
| 객체 | { name : ‘Jello’, address: ‘Yongin’ } |
| 배열 | [1, 2, 3] |
| 함수 | function() {} |
| 정규 표현식 | /[A-Z]+/g |

## 5.3 표현식

표현식(expression)은 값으로 평가될 수 있는 문(statement)이다. 따라서 표현식이 평가되면 **새로운 값이 생성**되거나 **기존의 값을 참조**한다. 앞서 살펴본 리터럴도 값을 생성하기 때문에 표현식이다.

값으로 평가될 수 있는 문은 모두 표현식이다.

```jsx
// 리터럴 표현식
10
'Jello'

let sum = 10 + 20;
// 식별자 표현식
sum

// 연산자 표현식
10 + 20;
sum = 10;
sum !== 10;

function square() {}
// 함수/메서드 호출 표현식
square()
```

표현식은 값으로 평가된다. 이때, 표현식과 평가된 값은 동등한 관계다. 그래서 문법적으로 값이 위치할 수 있는 곳에는 표현식도 위치할 수 있다. 즉, 치환/대입이 가능하다.

```jsx
let x = 1 + 2;
let y = 3 + 1 + 2; // let y = 3 + x 로 대체할 수 있다.
```

## 5.4 문

문(statement)은 프로그램을 구성하는 기본 단위이자 최소 실행 단위다.

문은 여러 토큰으로 구성된다. 여기서 토큰(token)이란 문법적으로 더 이상 나눌 수 없는 코드의 기본 요소를 의미한다. 키워드, 식별자, 연산자, 리터럴, 세미콜론, 마침표 등은 문법적인 의미를 가지고 더 이상 문법적으로 나눌 수 없기 때문에 모두 토큰이다.

![statement_token](https://user-images.githubusercontent.com/60080167/229607565-b6a989f1-af61-4e81-bd74-64a7050164a2.png)

문은 **명령문**이라고도 불리며, 선언문, 할당문, 조건문, 반복문 등으로 구분한다.

## 5.5 세미콜론과 세미콜론 자동 삽입 기능

세미콜론(;)은 문의 종료를 의미한다. 자바스크립트 엔진은 이 세미콜론으로 문의 종료 위치를 파악하고 순차적으로 문을 실행한다. 따라서 문을 끝낼 때는 세미콜론을 붙여야 한다. 단, 중괄호로 문을 묶은 코드 블록({ … })에는 세미콜론을 붙이지 않는다. 이런 코드 블록은 문의 종료를 의미하는 자체 종결성(self closing)을 갖기 때문이다.

자바스크립트 엔진이 소스코드를 해석할 때, 문의 끝이라고 예측되는 지점에 세미콜론을 자동으로 붙여준다. 이를 세미콜론 자동 삽입 기능(ASI, Automatic Semicolon Insertion)이라고 불리고 암묵적으로 수행된다. 하지만, 세미콜론 자동 삽입 기능의 동작을 개발자가 잘못 예측할 수 있는 경우도 분명히 존재한다.

```jsx
function foo() {
	return
		{}
	// ASI의 동작 결과 => return; {};
	// 개발자의 예측 => return {};
}
```

또한 ESLint 와 같은 정적 분석 도구나 TC39(ECMAScript 기술 위원회)에서도 세미콜론 사용을 권장하기 때문에, 다른 개발자들과의 소통 중 착각을 줄이기 위해서 붙여주는 것이 바람직하겠다.

## 5.6 표현식인 문과 표현식이 아닌 문

표현식인 문과 표현식이 아닌 문을 구별하는 가장 간단하고 명료한 방법은 **변수에 할당해보는 것**이다.

```jsx
var x;
x = 100;

var foo = var x // 변수 선언문은 값처럼 사용할 수 없기 때문에 표현식이 아니다.

var foo = x = 100 // 할당문은 연산자 표현식이므로 값처럼 할당할 수 있다.
console.log(foo); // => 100
```

크롬 개발자 도구에서는 표현식은 평가된 값을 반환한다. 반면, 표현식이 아닌 문은 완료 값(completion value)인 undefined를 반환한다.

## 출처
- [https://velog.io/@chappi/자바스크립트를-배워보자-4일차-표현식과-문](https://velog.io/@chappi/%EC%9E%90%EB%B0%94%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8%EB%A5%BC-%EB%B0%B0%EC%9B%8C%EB%B3%B4%EC%9E%90-4%EC%9D%BC%EC%B0%A8-%ED%91%9C%ED%98%84%EC%8B%9D%EA%B3%BC-%EB%AC%B8)