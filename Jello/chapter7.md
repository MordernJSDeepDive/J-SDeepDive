# Chapter7. 연산자

연산자(operator)는 하나 이상의 표현식을 대상으로 연산을 수행해 하나의 값을 만든다.

연산의 대상은 피연산자(operand)라고 하며 값으로 평가될 수 있는 표현식이어야 한다.

자바스크립트에서 제공하는 연산자는 아래와 같다.

## 7.1 산술 연산자

피연산자를 대상으로 수학적 계산을 수행하고 새로운 숫자 값을 만든다.

산술 연산이 불가능할 경우 `NaN`을 반환한다.

### 1) 이항 산술 연산자

**2개의 피연산자**를 산술 연산해 숫자 값을 만든다.

부수 효과가 없기 때문에 피연산자의 값이 바뀌는 경우는 없다. 언제나 새로운 값을 만들어 낸다.

```jsx
1 + 2;
3 - 4;
5 * 6;
7 / 8;
9 % 10;
```

### 2) 단항 산술 연산자

**1개의 피연산자**를 산술 연산하여 숫자 값을 만든다.

증가/감소(++/—) 연산자

- **피연산자의 값을 변경하는 부수 효과가 있다.**

```jsx
let x = 1;
x++;
console.log(x); // => 2

x--;
console.log(x); // => 1
```

- 증가/감소 연산자는 위치에 의미가 있다.
    - 피연산자 앞에 위치 : 먼저 피연산자의 값을 증가/감소시킨 후, 다른 연산을 수행한다.
    - 피연산자 뒤에 위치 : 먼저 다른 연산을 수행한 후, 피연산자의 값을 증가/감소시킨다.

`+` 단항 연산자

- 피연산자를 숫자 타입으로 변환하여 반환한다.
- 숫자 타입으로 변환한 값을 생성하여 반환한다. (피연산자의 변경 X)

```jsx
let x = '1';

console.log(+x); // 1
// 부수 효과는 없다.
console.log(x); // '1'

x = true;
console.log(+x); // 1
// 부수 효과는 없다.
console.log(x); // true

x = 'Hello';
console.log(+x); // NaN
// 부수 효과는 없다.
console.log(x); // 'Hello'
```

`-`단항 연산자

- 피연산자의 부호를 반전한 값을 생성하여 반환한다. (피연산자 변경 X)
- `+`단항 연산자와 마찬가지로 산술 연산이 불가능한 값은 NaN을 반환한다.

### 3) 문자열 연결 연산자

+연산자는 피연산자 중 하나 이상이 문자열인 경우 문자열 연결 연산자로 동작한다.

개발자의 의도와는 상관없이 자바스크립트 엔진에 의해 **암묵적인 타입 변환(또는 타입 강제 변환)**이 일어난다.

```jsx
'1' + 2; // '12'
```

## 7.2 할당 연산자

우항의 피연산자를 좌항의 변수에 할당한다. 변수 값이 변하는 부수 효과가 있다.

```jsx
let x;

x = 10;
x += 5;
x -= 5;
x *= 5;
x /= 5;
x %/ 5;
```

할당문은 **할당된 값으로 평가**되는 표현식이다. 그래서 아래와 같은 연쇄 할당도 가능하다.

```jsx
let a, b, c;
a = b = c = 10;

console.log(a, b, c); // 10 10 10
```

## 7.3 비교 연산자

좌항/우항 비교 후 불리언 값을 반환한다. if문이나 for문 등의 제어식에서 주로 사용한다.

### 1) 동등/일치 비교 연산자

동등 비교(`==`)

- 피연산자를 비교할 때, 먼저 암묵적 타입 변환으로 타입을 일치시킨다.
- 결과를 예측하기 어렵고 실수가 생길 수 있다.
    
    ```jsx
    5 == '5' // true
    ```
    

일치 비교(`===`)

- 좌항과 우항의 피연산자들이 **타입도 같고**, **값도 일치**하는 경우에만 true를 반환한다.
    
    ```jsx
    5 === '5' // false
    ```
    
- NaN은 자신과 일치하지 않는 유일한 값이다. 숫자가 NaN을 조사하기 위해서는 isNaN을 사용해야한다.
    
    ```jsx
    NaN === NaN; // false
    isNaN(NaN); // true
    ```
    
- +0은 -0과 동일하다고 평가한다. ES6에서 도입된 [Object.is](http://Object.is) 메서드로 둘을 구분할 수 있다.
    
    ```jsx
    -0 === +0; // true
    Object.is(-0, +0); // false
    ```
    

### 2) 대소 관계 비교 연산자

피연산자의 크기를 비교하여 불리언 값을 반환한다.

## 7.4 삼항 조건 연산자

삼항 조건 연산자(ternary operator)는 조건식의 평가에 따라 반환할 값을 결정한다. 부수 효과는 없다.

![ternary-operator](https://user-images.githubusercontent.com/60080167/229861615-00eeea9e-ded2-483c-aaa3-edd481fe442e.png)

조건식의 평가 결과가 불리언 값이 아니면 암묵적 타입 변환된다.

### if-else문이 있는데, 왜 사용할까?

삼항 조건 연산자 표현식은 **값처럼 사용할 수 있다**. 반면, if-else 문은 표현식이 아닌 문이기 때문에 값처럼 사용할 수 없다. 아래와 같이 변수에 할당할 수 있다.

```jsx
let resut;
result = x % 2 ? '홀수' : '짝수';
result = if (x % 2) { result = '홀수' } else { result = '짝수' }; // Uncaught SyntaxError: Unexpected token 'if'
```

그렇지만, 조건이 여러 개라면 if-else의 가독성이 더 좋다.

## 7.5 논리 연산자

`||`, `&&`, `!`

논리 부정 연산자는 언제나 불리언 값을 반환한다. 피연산자가 불리언 값이 아니라면 암묵적 타입 변환으로 불리언을 반환한다.

## 7.6 쉼표 연산자

- 차례대로 평가
- 마지막 피연산자의 평가 결과 반환

## 7.7 그룹 연산자

소괄호(`()`)로 피연산자를 감싸는 연산자. 피연산자인 표현식을 **가장 먼저 평가**한다.

이를 이용해 연산자들의 우선순위를 조절할 수 있다.

## 7.8 typeof 연산자

피연산자의 데이터 타입을 **문자열로** 반환한다.

반환하는 값

- “string”
- “number”
- “boolean”
- “undefined”
- “symbol”
- “object”
- “function”

### “null” 값은 반환하지 않는다?

null 값을 연산하면 **“object”를 반환**한다. 이것은 자바스크립트의 버그인데 기존 코드에 영향을 줄 수 있기 때문에 아직까지 수정하지 못 했다.

null 타입을 확인할 때는 일치 연산자(`===`)를 사용하면 된다.

### 선언하지 않은 식별자는 “undefined”를 반환한다?

```jsx
typeof undeclared; // undefined
```

## 7.9 지수 연산자

ES7에서 도입되었다. 좌항을 밑으로, 우항을 지수로 거듭 제곱하여 숫자 값을 반환한다.

Nested할 때 Math.pow보다 가독성이 좋다.

```jsx
// 결과는 같지만 지수 연산자가 더 간결하고 이해하기 쉽다.
2 ** 2 ** 2; // 16
Math.pow(2, Math.pow(2, 2)); // 16
```

**음수를 밑으로** 거듭제곱을 하기 위해서는 **괄호로 묶어야 한다**.

```jsx
-5**2; // Uncaught SyntaxError: Unary operator used immediately before exponentiation expression. Parenthesis must be used to disambiguate operator precedence
(-5)**2; // 25
```

할당 연산자와 함께 사용할 수 있다.

```jsx
let num = 5;
num **= 2; // 25
```

## 7.10 그외의 연산자들

## 7.11 연산자의 부수 효과

부수 효과는 다른 코드에 영향을 주는 것을 의미한다.

부수 효과가 있는 연산자

- 할당 연산자(=) : 변수의 값을 바꾼다.
- 증가/감소 연산자(++/—) : 변수의 값을 바꾼다.
- delete 연산자 : 객체의 프로퍼티 삭제

## 7.12 연산자 우선순위

연산자 우선순위가 가장 높은 **그룹 연산자를 사용해서 우선순위를 조절**하자.

## 7.13 연산자 결합 순서